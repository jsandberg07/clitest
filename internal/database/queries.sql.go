// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const getCageCardsActive = `-- name: GetCageCardsActive :many
SELECT cage_cards.cc_id, investigators.i_name, protocols.p_number, strains.s_name, cage_cards.activated_on, cage_cards.deactivated_on, orders.order_number
FROM cage_cards
INNER JOIN investigators ON cage_cards.investigator_id = investigators.id
INNER JOIN protocols ON cage_cards.protocol_id = protocols.id
LEFT JOIN strains ON cage_cards.strain = strains.id
LEFT JOIN orders ON cage_cards.order_id = orders.id
WHERE cage_cards.activated_on IS NOT NULL and cage_cards.deactivated_on IS NULL
ORDER BY cage_cards.cc_id ASC
`

type GetCageCardsActiveRow struct {
	CcID          int32
	IName         string
	PNumber       string
	SName         sql.NullString
	ActivatedOn   sql.NullTime
	DeactivatedOn sql.NullTime
	OrderNumber   sql.NullString
}

func (q *Queries) GetCageCardsActive(ctx context.Context) ([]GetCageCardsActiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getCageCardsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCageCardsActiveRow
	for rows.Next() {
		var i GetCageCardsActiveRow
		if err := rows.Scan(
			&i.CcID,
			&i.IName,
			&i.PNumber,
			&i.SName,
			&i.ActivatedOn,
			&i.DeactivatedOn,
			&i.OrderNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCageCardsAll = `-- name: GetCageCardsAll :many
SELECT cage_cards.cc_id, investigators.i_name, protocols.p_number, strains.s_name, cage_cards.activated_on, cage_cards.deactivated_on, orders.order_number
FROM cage_cards
INNER JOIN investigators ON cage_cards.investigator_id = investigators.id
INNER JOIN protocols ON cage_cards.protocol_id = protocols.id
LEFT JOIN strains ON cage_cards.strain = strains.id
LEFT JOIN orders ON cage_cards.order_id = orders.id
ORDER BY cage_cards.cc_id ASC
`

type GetCageCardsAllRow struct {
	CcID          int32
	IName         string
	PNumber       string
	SName         sql.NullString
	ActivatedOn   sql.NullTime
	DeactivatedOn sql.NullTime
	OrderNumber   sql.NullString
}

func (q *Queries) GetCageCardsAll(ctx context.Context) ([]GetCageCardsAllRow, error) {
	rows, err := q.db.QueryContext(ctx, getCageCardsAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCageCardsAllRow
	for rows.Next() {
		var i GetCageCardsAllRow
		if err := rows.Scan(
			&i.CcID,
			&i.IName,
			&i.PNumber,
			&i.SName,
			&i.ActivatedOn,
			&i.DeactivatedOn,
			&i.OrderNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCageCardsInvestigator = `-- name: GetCageCardsInvestigator :many
SELECT cage_cards.cc_id, investigators.i_name, protocols.p_number, strains.s_name, cage_cards.activated_on, cage_cards.deactivated_on, orders.order_number
FROM cage_cards
INNER JOIN investigators ON cage_cards.investigator_id = investigators.id
INNER JOIN protocols ON cage_cards.protocol_id = protocols.id
LEFT JOIN strains ON cage_cards.strain = strains.id
LEFT JOIN orders ON cage_cards.order_id = orders.id
WHERE (activated_on IS NOT NULL AND activated_on >= $1) AND (deactivated_on <= $2 OR deactivated_on IS NULL)
AND cage_cards.investigator_id = $3
ORDER BY cage_cards.cc_id ASC
`

type GetCageCardsInvestigatorParams struct {
	ActivatedOn    sql.NullTime
	DeactivatedOn  sql.NullTime
	InvestigatorID uuid.UUID
}

type GetCageCardsInvestigatorRow struct {
	CcID          int32
	IName         string
	PNumber       string
	SName         sql.NullString
	ActivatedOn   sql.NullTime
	DeactivatedOn sql.NullTime
	OrderNumber   sql.NullString
}

func (q *Queries) GetCageCardsInvestigator(ctx context.Context, arg GetCageCardsInvestigatorParams) ([]GetCageCardsInvestigatorRow, error) {
	rows, err := q.db.QueryContext(ctx, getCageCardsInvestigator, arg.ActivatedOn, arg.DeactivatedOn, arg.InvestigatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCageCardsInvestigatorRow
	for rows.Next() {
		var i GetCageCardsInvestigatorRow
		if err := rows.Scan(
			&i.CcID,
			&i.IName,
			&i.PNumber,
			&i.SName,
			&i.ActivatedOn,
			&i.DeactivatedOn,
			&i.OrderNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCageCardsOrder = `-- name: GetCageCardsOrder :many
SELECT cage_cards.cc_id, investigators.i_name, protocols.p_number, strains.s_name, cage_cards.activated_on, cage_cards.deactivated_on, orders.order_number
FROM cage_cards
INNER JOIN investigators ON cage_cards.investigator_id = investigators.id
INNER JOIN protocols ON cage_cards.protocol_id = protocols.id
LEFT JOIN strains ON cage_cards.strain = strains.id
LEFT JOIN orders ON cage_cards.order_id = orders.id
WHERE order_id = $1
ORDER BY cage_cards.cc_id ASC
`

type GetCageCardsOrderRow struct {
	CcID          int32
	IName         string
	PNumber       string
	SName         sql.NullString
	ActivatedOn   sql.NullTime
	DeactivatedOn sql.NullTime
	OrderNumber   sql.NullString
}

func (q *Queries) GetCageCardsOrder(ctx context.Context, orderID uuid.NullUUID) ([]GetCageCardsOrderRow, error) {
	rows, err := q.db.QueryContext(ctx, getCageCardsOrder, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCageCardsOrderRow
	for rows.Next() {
		var i GetCageCardsOrderRow
		if err := rows.Scan(
			&i.CcID,
			&i.IName,
			&i.PNumber,
			&i.SName,
			&i.ActivatedOn,
			&i.DeactivatedOn,
			&i.OrderNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCageCardsProtocol = `-- name: GetCageCardsProtocol :many
SELECT cage_cards.cc_id, investigators.i_name, protocols.p_number, strains.s_name, cage_cards.activated_on, cage_cards.deactivated_on, orders.order_number
FROM cage_cards
INNER JOIN investigators ON cage_cards.investigator_id = investigators.id
INNER JOIN protocols ON cage_cards.protocol_id = protocols.id
LEFT JOIN strains ON cage_cards.strain = strains.id
LEFT JOIN orders ON cage_cards.order_id = orders.id
WHERE (activated_on IS NOT NULL AND activated_on >= $1) AND (deactivated_on <= $2 OR deactivated_on IS NULL)
AND cage_cards.protocol_id = $3
ORDER BY cage_cards.cc_id ASC
`

type GetCageCardsProtocolParams struct {
	ActivatedOn   sql.NullTime
	DeactivatedOn sql.NullTime
	ProtocolID    uuid.UUID
}

type GetCageCardsProtocolRow struct {
	CcID          int32
	IName         string
	PNumber       string
	SName         sql.NullString
	ActivatedOn   sql.NullTime
	DeactivatedOn sql.NullTime
	OrderNumber   sql.NullString
}

func (q *Queries) GetCageCardsProtocol(ctx context.Context, arg GetCageCardsProtocolParams) ([]GetCageCardsProtocolRow, error) {
	rows, err := q.db.QueryContext(ctx, getCageCardsProtocol, arg.ActivatedOn, arg.DeactivatedOn, arg.ProtocolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCageCardsProtocolRow
	for rows.Next() {
		var i GetCageCardsProtocolRow
		if err := rows.Scan(
			&i.CcID,
			&i.IName,
			&i.PNumber,
			&i.SName,
			&i.ActivatedOn,
			&i.DeactivatedOn,
			&i.OrderNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCardsDateRange = `-- name: GetCardsDateRange :many
SELECT cage_cards.cc_id, investigators.i_name, protocols.p_number, strains.s_name, cage_cards.activated_on, cage_cards.deactivated_on, orders.order_number
FROM cage_cards
INNER JOIN investigators ON cage_cards.investigator_id = investigators.id
INNER JOIN protocols ON cage_cards.protocol_id = protocols.id
LEFT JOIN strains ON cage_cards.strain = strains.id
LEFT JOIN orders ON cage_cards.order_id = orders.id
WHERE (activated_on IS NOT NULL AND activated_on >= $1) AND (deactivated_on <= $2 OR deactivated_on IS NULL)
ORDER BY cage_cards.cc_id ASC
`

type GetCardsDateRangeParams struct {
	ActivatedOn   sql.NullTime
	DeactivatedOn sql.NullTime
}

type GetCardsDateRangeRow struct {
	CcID          int32
	IName         string
	PNumber       string
	SName         sql.NullString
	ActivatedOn   sql.NullTime
	DeactivatedOn sql.NullTime
	OrderNumber   sql.NullString
}

func (q *Queries) GetCardsDateRange(ctx context.Context, arg GetCardsDateRangeParams) ([]GetCardsDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getCardsDateRange, arg.ActivatedOn, arg.DeactivatedOn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCardsDateRangeRow
	for rows.Next() {
		var i GetCardsDateRangeRow
		if err := rows.Scan(
			&i.CcID,
			&i.IName,
			&i.PNumber,
			&i.SName,
			&i.ActivatedOn,
			&i.DeactivatedOn,
			&i.OrderNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
