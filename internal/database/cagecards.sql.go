// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: cagecards.sql

package database

import (
	"context"
	"database/sql"
)

const activateCageCard = `-- name: ActivateCageCard :one
INSERT INTO cage_cards(cc_id, activated, deactivated, investigator)
VALUES($1, $2, NULL, $3)
RETURNING cc_id, activated, deactivated, investigator
`

type ActivateCageCardParams struct {
	CcID         int32
	Activated    sql.NullTime
	Investigator string
}

func (q *Queries) ActivateCageCard(ctx context.Context, arg ActivateCageCardParams) (CageCard, error) {
	row := q.db.QueryRowContext(ctx, activateCageCard, arg.CcID, arg.Activated, arg.Investigator)
	var i CageCard
	err := row.Scan(
		&i.CcID,
		&i.Activated,
		&i.Deactivated,
		&i.Investigator,
	)
	return i, err
}

const getCageCards = `-- name: GetCageCards :many
SELECT cc_id, activated, deactivated, investigator FROM cage_cards
ORDER BY cc_id ASC
`

func (q *Queries) GetCageCards(ctx context.Context) ([]CageCard, error) {
	rows, err := q.db.QueryContext(ctx, getCageCards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CageCard
	for rows.Next() {
		var i CageCard
		if err := rows.Scan(
			&i.CcID,
			&i.Activated,
			&i.Deactivated,
			&i.Investigator,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetCageCards = `-- name: ResetCageCards :exec
DELETE FROM cage_cards *
`

func (q *Queries) ResetCageCards(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetCageCards)
	return err
}
