// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: cagecards.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const activateCageCard = `-- name: ActivateCageCard :one

INSERT INTO cage_cards(cc_id, activated_on, deactivated_on, investigator_id)
VALUES($1, $2, NULL, $3)
RETURNING cc_id, activated_on, deactivated_on, investigator_id, strain, notes, activated_by, deactivated_by
`

type ActivateCageCardParams struct {
	CcID           int32
	ActivatedOn    sql.NullTime
	InvestigatorID uuid.UUID
}

// this is bunk and it's here just to not break sqlc
func (q *Queries) ActivateCageCard(ctx context.Context, arg ActivateCageCardParams) (CageCard, error) {
	row := q.db.QueryRowContext(ctx, activateCageCard, arg.CcID, arg.ActivatedOn, arg.InvestigatorID)
	var i CageCard
	err := row.Scan(
		&i.CcID,
		&i.ActivatedOn,
		&i.DeactivatedOn,
		&i.InvestigatorID,
		&i.Strain,
		&i.Notes,
		&i.ActivatedBy,
		&i.DeactivatedBy,
	)
	return i, err
}

const getCageCards = `-- name: GetCageCards :many
SELECT cc_id, activated_on, deactivated_on, investigator_id, strain, notes, activated_by, deactivated_by FROM cage_cards
ORDER BY cc_id ASC
`

func (q *Queries) GetCageCards(ctx context.Context) ([]CageCard, error) {
	rows, err := q.db.QueryContext(ctx, getCageCards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CageCard
	for rows.Next() {
		var i CageCard
		if err := rows.Scan(
			&i.CcID,
			&i.ActivatedOn,
			&i.DeactivatedOn,
			&i.InvestigatorID,
			&i.Strain,
			&i.Notes,
			&i.ActivatedBy,
			&i.DeactivatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetCageCards = `-- name: ResetCageCards :exec
DELETE FROM cage_cards *
`

func (q *Queries) ResetCageCards(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetCageCards)
	return err
}
